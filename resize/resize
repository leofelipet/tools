#!/bin/bash

# Script de processamento de imagens
# Recorta, converte para WebP e comprime imagens

# Valores padrão
WIDTH=512
HEIGHT=512
QUALITY=70
OUTPUT_DIR="processadas"
PROCESS_ALL=false
INPUT_PATH=""
MODE="smart" # smart, crop, fit, fill

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Função de ajuda
show_help() {
    echo "Uso: $0 [OPÇÕES] <arquivo_ou_pasta>"
    echo ""
    echo "OPÇÕES:"
    echo "  -w, --width WIDTH       Largura do resultado (padrão: 512)"
    echo "  -h, --height HEIGHT     Altura do resultado (padrão: 512)"
    echo "  -q, --quality QUALITY   Qualidade da compressão 1-100 (padrão: 70)"
    echo "  -o, --output DIR        Diretório de saída (padrão: 'processadas')"
    echo "  -a, --all               Processar todas as imagens da pasta"
    echo "  -m, --mode MODE         Modo de processamento (padrão: smart)"
    echo "                          Modos disponíveis:"
    echo "                          • smart: Redimensiona mantendo proporção e preenche"
    echo "                          • crop: Recorta do centro (zoom)"
    echo "                          • fit: Ajusta dentro das dimensões (pode ter bordas)"
    echo "                          • fill: Preenche todo espaço distorcendo se necessário"
    echo "                          • contain: Mantém imagem inteira com fundo branco"
    echo "  --help                  Mostrar esta ajuda"
    echo ""
    echo "EXEMPLOS:"
    echo "  $0 imagem.jpg                         # Processa uma imagem (modo smart)"
    echo "  $0 -a /caminho/pasta                  # Processa todas as imagens"
    echo "  $0 -m crop imagem.jpg                 # Força recorte central"
    echo "  $0 -m fit -w 1024 -h 1024 img.png    # Ajusta sem cortar"
    exit 0
}

# Verificar dependências
check_dependencies() {
    local missing_deps=()
    
    if ! command -v convert &> /dev/null; then
        missing_deps+=("imagemagick")
    fi
    
    if ! command -v identify &> /dev/null; then
        missing_deps+=("imagemagick")
    fi
    
    if ! command -v cwebp &> /dev/null; then
        missing_deps+=("webp")
    fi
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        echo -e "${RED}Erro: Dependências faltando!${NC}"
        echo "Por favor, instale os seguintes pacotes:"
        for dep in "${missing_deps[@]}"; do
            echo "  - $dep"
        done
        echo ""
        echo "Ubuntu/Debian: sudo apt-get install imagemagick webp"
        echo "Fedora/RHEL: sudo dnf install ImageMagick libwebp-tools"
        echo "macOS: brew install imagemagick webp"
        exit 1
    fi
}

# Processar argumentos
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -w|--width)
                WIDTH="$2"
                shift 2
                ;;
            -h|--height)
                HEIGHT="$2"
                shift 2
                ;;
            -q|--quality)
                QUALITY="$2"
                shift 2
                ;;
            -o|--output)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -m|--mode)
                MODE="$2"
                shift 2
                ;;
            -a|--all)
                PROCESS_ALL=true
                shift
                ;;
            --help)
                show_help
                ;;
            *)
                INPUT_PATH="$1"
                shift
                ;;
        esac
    done
}

# Validar entrada
validate_input() {
    if [ -z "$INPUT_PATH" ]; then
        echo -e "${RED}Erro: Nenhum arquivo ou pasta especificado!${NC}"
        echo "Use --help para ver as opções"
        exit 1
    fi
    
    if [ ! -e "$INPUT_PATH" ]; then
        echo -e "${RED}Erro: '$INPUT_PATH' não existe!${NC}"
        exit 1
    fi
    
    if [ -f "$INPUT_PATH" ] && [ "$PROCESS_ALL" = true ]; then
        echo -e "${YELLOW}Aviso: -a ignorado, processando arquivo único${NC}"
        PROCESS_ALL=false
    fi
    
    if [ -d "$INPUT_PATH" ] && [ "$PROCESS_ALL" = false ]; then
        echo -e "${RED}Erro: '$INPUT_PATH' é uma pasta. Use -a para processar todas as imagens${NC}"
        exit 1
    fi
    
    # Validar modo
    if [[ ! "$MODE" =~ ^(smart|crop|fit|fill|contain)$ ]]; then
        echo -e "${RED}Erro: Modo '$MODE' inválido!${NC}"
        echo "Modos válidos: smart, crop, fit, fill, contain"
        exit 1
    fi
}

# Obter dimensões da imagem
get_image_dimensions() {
    local img="$1"
    identify -format "%wx%h" "$img" 2>/dev/null
}

# Processar uma única imagem
process_image() {
    local input_file="$1"
    local output_dir="$2"
    local filename=$(basename "$input_file")
    local name="${filename%.*}"
    local temp_file="${output_dir}/${name}_temp.png"
    local output_file="${output_dir}/${name}.webp"
    
    echo -e "${GREEN}Processando:${NC} $filename"
    
    # Criar diretório de saída se não existir
    mkdir -p "$output_dir"
    
    # Obter dimensões originais
    local original_dims=$(get_image_dimensions "$input_file")
    echo "  → Dimensões originais: $original_dims"
    echo "  → Modo: $MODE → ${WIDTH}x${HEIGHT}px"
    
    case "$MODE" in
        "smart")
            # Modo inteligente: redimensiona para cobrir toda área e recorta o excesso
            echo "  → Aplicando redimensionamento inteligente..."
            convert "$input_file" \
                -resize "${WIDTH}x${HEIGHT}^" \
                -gravity center \
                -extent "${WIDTH}x${HEIGHT}" \
                "$temp_file"
            ;;
            
        "crop")
            # Modo crop: recorta do centro (comportamento original)
            echo "  → Recortando do centro..."
            convert "$input_file" \
                -gravity center \
                -crop "${WIDTH}x${HEIGHT}+0+0" \
                +repage \
                "$temp_file"
            ;;
            
        "fit")
            # Modo fit: redimensiona mantendo proporção (pode ter espaço vazio)
            echo "  → Ajustando dentro das dimensões..."
            convert "$input_file" \
                -resize "${WIDTH}x${HEIGHT}" \
                -gravity center \
                -background white \
                -extent "${WIDTH}x${HEIGHT}" \
                "$temp_file"
            ;;
            
        "fill")
            # Modo fill: preenche exatamente (pode distorcer)
            echo "  → Preenchendo dimensões exatas..."
            convert "$input_file" \
                -resize "${WIDTH}x${HEIGHT}!" \
                "$temp_file"
            ;;
            
        "contain")
            # Modo contain: mantém imagem inteira com padding
            echo "  → Mantendo imagem completa com bordas..."
            convert "$input_file" \
                -thumbnail "${WIDTH}x${HEIGHT}" \
                -gravity center \
                -background white \
                -extent "${WIDTH}x${HEIGHT}" \
                "$temp_file"
            ;;
    esac
    
    if [ $? -ne 0 ]; then
        echo -e "${RED}  ✗ Erro ao processar imagem${NC}"
        rm -f "$temp_file"
        return 1
    fi
    
    # Converter para WebP com compressão
    echo "  → Convertendo para WebP com qualidade ${QUALITY}%..."
    cwebp -q "$QUALITY" "$temp_file" -o "$output_file" &> /dev/null
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}  ✓ Salvo em:${NC} $output_file"
        
        # Mostrar informações do arquivo
        local original_size=$(du -h "$input_file" | cut -f1)
        local new_size=$(du -h "$output_file" | cut -f1)
        echo "  → Tamanho: $original_size → $new_size"
    else
        echo -e "${RED}  ✗ Erro ao converter para WebP${NC}"
        rm -f "$temp_file"
        return 1
    fi
    
    # Limpar arquivo temporário
    rm -f "$temp_file"
    
    return 0
}

# Função para processar em lote com preview
batch_preview() {
    local images=()
    
    # Coletar imagens
    shopt -s nocaseglob
    for img in "$INPUT_PATH"/*.{jpg,jpeg,png,gif,bmp,tiff,tif}; do
        if [ -f "$img" ]; then
            images+=("$img")
        fi
    done
    shopt -u nocaseglob
    
    if [ ${#images[@]} -eq 0 ]; then
        echo -e "${YELLOW}Nenhuma imagem encontrada no diretório${NC}"
        return 1
    fi
    
    echo -e "${BLUE}Encontradas ${#images[@]} imagens para processar${NC}"
    echo "Primeiras 5 imagens:"
    for i in "${images[@]:0:5}"; do
        echo "  - $(basename "$i")"
    done
    
    if [ ${#images[@]} -gt 5 ]; then
        echo "  ... e mais $((${#images[@]} - 5)) imagens"
    fi
    
    echo ""
    read -p "Continuar com o processamento? (s/n): " -n 1 -r
    echo ""
    
    if [[ ! $REPLY =~ ^[Ss]$ ]]; then
        echo "Processamento cancelado"
        return 1
    fi
    
    return 0
}

# Função principal
main() {
    check_dependencies
    parse_args "$@"
    validate_input
    
    local processed=0
    local failed=0
    
    echo "========================================="
    echo "Configurações:"
    echo "  Dimensões: ${WIDTH}x${HEIGHT}px"
    echo "  Qualidade: ${QUALITY}%"
    echo "  Modo: ${MODE}"
    echo "  Saída: ${OUTPUT_DIR}/"
    echo "========================================="
    echo ""
    
    if [ -f "$INPUT_PATH" ]; then
        # Processar arquivo único
        local dir=$(dirname "$INPUT_PATH")
        local output_path="${dir}/${OUTPUT_DIR}"
        
        if process_image "$INPUT_PATH" "$output_path"; then
            processed=$((processed + 1))
        else
            failed=$((failed + 1))
        fi
    else
        # Perguntar antes de processar múltiplos arquivos
        if ! batch_preview; then
            exit 0
        fi
        
        local output_path="${INPUT_PATH}/${OUTPUT_DIR}"
        
        # Processar múltiplos arquivos
        shopt -s nocaseglob
        for img in "$INPUT_PATH"/*.{jpg,jpeg,png,gif,bmp,tiff,tif}; do
            if [ -f "$img" ]; then
                if process_image "$img" "$output_path"; then
                    processed=$((processed + 1))
                else
                    failed=$((failed + 1))
                fi
                echo ""
            fi
        done
        shopt -u nocaseglob
    fi
    
    # Resumo final
    echo "========================================="
    if [ $processed -gt 0 ]; then
        echo -e "${GREEN}Processamento concluído!${NC}"
    fi
    echo "  Processadas: $processed imagens"
    if [ $failed -gt 0 ]; then
        echo -e "  ${RED}Falhas: $failed imagens${NC}"
    fi
    echo "========================================="
}

# Executar script
main "$@"